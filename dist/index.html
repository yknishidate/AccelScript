
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JSS - JavaScript Shader Extension Demo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
    }
    .output {
      margin-top: 20px;
      border: 1px solid #ddd;
      padding: 10px;
      border-radius: 5px;
    }
    h1 {
      color: #333;
    }
  </style>
</head>
<body>
  <h1>JSS - JavaScript Shader Extension Demo</h1>
  <p>このデモは、JavaScriptを拡張して@compute属性を持つ関数をWGSLのcompute shaderに変換するトランスパイラーの例です。</p>
  
  <h2>元のコード（@compute属性を含む）</h2>
  <pre id="source-code">/**
 * JSS - JavaScript Shader Extension の実用例
 * WebGPUを使用して@compute関数を実行する例
 */

// @compute属性を持つ関数（WGSLのcompute shaderに変換される）
// バッファのバインディングはWGSLコードに自動的に追加されます
@compute
function addVectors(index) {
  // 入力バッファからデータを読み取り
  let a = inputA[index];
  let b = inputB[index];
  
  // 計算結果を出力バッファに書き込み
  output[index] = a + b;
}

// 実際のWGSLコードでは以下のようなバインディングが必要です
// @group(0) @binding(0) var&lt;storage, read&gt; inputA: array&lt;f32&gt;;
// @group(0) @binding(1) var&lt;storage, read&gt; inputB: array&lt;f32&gt;;
// @group(0) @binding(2) var&lt;storage, read_write&gt; output: array&lt;f32&gt;;

// WebGPUを初期化して計算を実行する関数
async function runComputation() {
  // WebGPUアダプタとデバイスを取得
  if (!navigator.gpu) {
    throw new Error('WebGPU is not supported in this browser');
  }
  
  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    throw new Error('Failed to get GPU adapter');
  }
  
  const device = await adapter.requestDevice();
  
  // 入力データを準備
  const data = new Float32Array([1, 2, 3, 4, 5, 6, 7, 8]);
  const inputABuffer = device.createBuffer({
    size: data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  
  const inputBBuffer = device.createBuffer({
    size: data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  
  const outputBuffer = device.createBuffer({
    size: data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
  });
  
  const stagingBuffer = device.createBuffer({
    size: data.byteLength,
    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
  });
  
  // 入力データをGPUバッファにコピー
  device.queue.writeBuffer(inputABuffer, 0, data);
  device.queue.writeBuffer(inputBBuffer, 0, data);
  
  // シェーダーモジュールを作成
  const shaderModule = device.createShaderModule({
    code: shaderCode.addVectors,
  });
  
  // バインドグループレイアウトとパイプラインレイアウトを作成
  const bindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.COMPUTE,
        buffer: { type: 'read-only-storage' }
      },
      {
        binding: 1,
        visibility: GPUShaderStage.COMPUTE,
        buffer: { type: 'read-only-storage' }
      },
      {
        binding: 2,
        visibility: GPUShaderStage.COMPUTE,
        buffer: { type: 'storage' }
      }
    ]
  });
  
  const pipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [bindGroupLayout]
  });
  
  // コンピュートパイプラインを作成
  const computePipeline = device.createComputePipeline({
    layout: pipelineLayout,
    compute: {
      module: shaderModule,
      entryPoint: 'addVectors'
    }
  });
  
  // バインドグループを作成
  const bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      {
        binding: 0,
        resource: {
          buffer: inputABuffer
        }
      },
      {
        binding: 1,
        resource: {
          buffer: inputBBuffer
        }
      },
      {
        binding: 2,
        resource: {
          buffer: outputBuffer
        }
      }
    ]
  });
  
  // コマンドエンコーダを作成
  const commandEncoder = device.createCommandEncoder();
  
  // コンピュートパスを作成
  const computePass = commandEncoder.beginComputePass();
  computePass.setPipeline(computePipeline);
  computePass.setBindGroup(0, bindGroup);
  
  // ワークグループ数を計算（ワークグループサイズ64に合わせて調整）
  // Math.ceilを使用して、すべての要素が処理されるようにする
  const workgroupSize = 64;
  const workgroupCount = Math.ceil(data.length / workgroupSize);
  computePass.dispatchWorkgroups(workgroupCount);
  
  computePass.end();
  
  // 結果をステージングバッファにコピー
  commandEncoder.copyBufferToBuffer(
    outputBuffer, 0,
    stagingBuffer, 0,
    data.byteLength
  );
  
  // コマンドをキューに送信
  const commands = commandEncoder.finish();
  device.queue.submit([commands]);
  
  // 結果を読み取り
  await stagingBuffer.mapAsync(GPUMapMode.READ);
  const resultData = new Float32Array(stagingBuffer.getMappedRange());
  
  // 結果を表示
  console.log('Input A:', data);
  console.log('Input B:', data);
  console.log('Result:', resultData);
  
  // リソースを解放
  stagingBuffer.unmap();
}

// 計算を実行
if (typeof window !== 'undefined') {
  window.addEventListener('load', () =&gt; {
    runComputation().catch(console.error);
  });
}

// Node.jsでの実行用（WebGPUがサポートされていない場合はスキップ）
if (typeof module !== 'undefined') {
  module.exports = { runComputation };
}
</pre>
  
  <h2>トランスパイル後のコード</h2>
  <pre id="transpiled-code">/**
 * JSS - JavaScript Shader Extension の実用例
 * WebGPUを使用して@compute関数を実行する例
 */

// @compute属性を持つ関数（WGSLのcompute shaderに変換される）
// バッファのバインディングはWGSLコードに自動的に追加されます

// 実際のWGSLコードでは以下のようなバインディングが必要です
// @group(0) @binding(0) var&lt;storage, read&gt; inputA: array&lt;f32&gt;;
// @group(0) @binding(1) var&lt;storage, read&gt; inputB: array&lt;f32&gt;;
// @group(0) @binding(2) var&lt;storage, read_write&gt; output: array&lt;f32&gt;;

// WebGPUを初期化して計算を実行する関数
async function runComputation() {
  // WebGPUアダプタとデバイスを取得
  if (!navigator.gpu) {
    throw new Error('WebGPU is not supported in this browser');
  }
  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    throw new Error('Failed to get GPU adapter');
  }
  const device = await adapter.requestDevice();

  // 入力データを準備
  const data = new Float32Array([1, 2, 3, 4, 5, 6, 7, 8]);
  const inputABuffer = device.createBuffer({
    size: data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
  });
  const inputBBuffer = device.createBuffer({
    size: data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
  });
  const outputBuffer = device.createBuffer({
    size: data.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
  });
  const stagingBuffer = device.createBuffer({
    size: data.byteLength,
    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
  });

  // 入力データをGPUバッファにコピー
  device.queue.writeBuffer(inputABuffer, 0, data);
  device.queue.writeBuffer(inputBBuffer, 0, data);

  // シェーダーモジュールを作成
  const shaderModule = device.createShaderModule({
    code: shaderCode.addVectors
  });

  // バインドグループレイアウトとパイプラインレイアウトを作成
  const bindGroupLayout = device.createBindGroupLayout({
    entries: [{
      binding: 0,
      visibility: GPUShaderStage.COMPUTE,
      buffer: {
        type: 'read-only-storage'
      }
    }, {
      binding: 1,
      visibility: GPUShaderStage.COMPUTE,
      buffer: {
        type: 'read-only-storage'
      }
    }, {
      binding: 2,
      visibility: GPUShaderStage.COMPUTE,
      buffer: {
        type: 'storage'
      }
    }]
  });
  const pipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [bindGroupLayout]
  });

  // コンピュートパイプラインを作成
  const computePipeline = device.createComputePipeline({
    layout: pipelineLayout,
    compute: {
      module: shaderModule,
      entryPoint: 'addVectors'
    }
  });

  // バインドグループを作成
  const bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [{
      binding: 0,
      resource: {
        buffer: inputABuffer
      }
    }, {
      binding: 1,
      resource: {
        buffer: inputBBuffer
      }
    }, {
      binding: 2,
      resource: {
        buffer: outputBuffer
      }
    }]
  });

  // コマンドエンコーダを作成
  const commandEncoder = device.createCommandEncoder();

  // コンピュートパスを作成
  const computePass = commandEncoder.beginComputePass();
  computePass.setPipeline(computePipeline);
  computePass.setBindGroup(0, bindGroup);

  // ワークグループ数を計算（ワークグループサイズ64に合わせて調整）
  // Math.ceilを使用して、すべての要素が処理されるようにする
  const workgroupSize = 64;
  const workgroupCount = Math.ceil(data.length / workgroupSize);
  computePass.dispatchWorkgroups(workgroupCount);
  computePass.end();

  // 結果をステージングバッファにコピー
  commandEncoder.copyBufferToBuffer(outputBuffer, 0, stagingBuffer, 0, data.byteLength);

  // コマンドをキューに送信
  const commands = commandEncoder.finish();
  device.queue.submit([commands]);

  // 結果を読み取り
  await stagingBuffer.mapAsync(GPUMapMode.READ);
  const resultData = new Float32Array(stagingBuffer.getMappedRange());

  // 結果を表示
  console.log('Input A:', data);
  console.log('Input B:', data);
  console.log('Result:', resultData);

  // リソースを解放
  stagingBuffer.unmap();
}

// 計算を実行
if (typeof window !== 'undefined') {
  window.addEventListener('load', () =&gt; {
    runComputation().catch(console.error);
  });
}

// Node.jsでの実行用（WebGPUがサポートされていない場合はスキップ）
if (typeof module !== 'undefined') {
  module.exports = {
    runComputation
  };
}

// Generated WGSL Shader Code
const shaderCode = {
  addVectors: `
@group(0) @binding(0) var&lt;storage, read&gt; inputA: array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read&gt; inputB: array&lt;f32&gt;;
@group(0) @binding(2) var&lt;storage, read_write&gt; output: array&lt;f32&gt;;

@compute @workgroup_size(64)  // 一般的なワークグループサイズ（GPUによって最適値は異なる）
fn addVectors(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) {
  // JavaScriptのindexパラメータをglobal_id.xにマッピング
  let index = global_id.x;
  
  // インデックスが配列の範囲内かチェック（バッファオーバーランを防止）
  if (index &lt; arrayLength(&output)) {
    
  // 入力バッファからデータを読み取り
  let a = inputA[index];
  let b = inputB[index];
  
  // 計算結果を出力バッファに書き込み
  output[index] = a + b;

  }
}
`
};
</pre>
  
  <h2>実行結果</h2>
  <div class="output" id="output">
    <p>WebGPUが利用可能な場合、ここに結果が表示されます。</p>
  </div>
  
  <script src="example.js"></script>
  <script>
    // 出力をキャプチャ
    const originalConsoleLog = console.log;
    const outputDiv = document.getElementById('output');
    
    console.log = function(...args) {
      originalConsoleLog.apply(console, args);
      
      const p = document.createElement('p');
      p.textContent = args.map(arg => {
        if (typeof arg === 'object') {
          return JSON.stringify(arg);
        }
        return String(arg);
      }).join(' ');
      
      outputDiv.appendChild(p);
    };
  </script>
</body>
</html>
